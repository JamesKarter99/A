/*
* ------------ Сортировка выбором ------------
^ O(n^2)
$ сортировка_выбором
? Алгоритм перебирает все элементы с 0 до n-1 позиции и на каждой итерации ищет минимальный элемент в подпоследовательности d[i ... n-1] с индексом iMin. Если найденый минимальный элемент с индексом iMin - это не тот же элемент, что с индексом i, то производим их обмен. То есть если до этого шанга была отсортирована подспоследовательность d[0 ... i - 1], то теперь отсортированной является d[0 ... i].

? Шаги алгоритма:
? 1. Находим минимальный элемент в текущем (начиная с i) списке;
? 2. Производим обмен этого значения со значением первой неотсортированной позиции (обмен не нужен, если минимальный элемент уже находится на данной позиции);
? 3. Теперь сортируем оставшуюся часть последовательности, не рассматривая уже отсортированную.

*/

vector <int> d(n);

// перебираем все элементы
for (int i(0); i < n; i++) {
    int iMin = i; // индекс минимального элемента

    // обновление индекса минимального элемента
    for (int j(i + 1); j < n; j++) {
        if (d[iMin] > d[j])
            iMin = j;
    }

	// обмен элементов
	if (i != iMin)
    	swap(d[i], d[iMin]);
}

//* версия алгоритма, когда ищется максимальный элемент
// перебираем все элементы
for (int i(n-1); i >= 0; i--) {
    int iMax = i; // индекс максимального элемента

    // обновление индекса максимального элемента
    for (int j(0); j < i; j++) {
        if (d[iMax] < d[j])
            iMax = j;
    }

    if (i != iMax)
        swap(d[i], d[iMax]);
}