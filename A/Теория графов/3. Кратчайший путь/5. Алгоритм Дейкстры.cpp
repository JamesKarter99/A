/*
* ------------ АЛГОРИТМ ДЕЙКСТРЫ ------------
^ O(n + m*log(n))
$ дейкстра $ дейкстра_с_восстановлением_пути
# список_смежности $ фибоначчиева_куча
? Алгоритм находит кратчайшие расстояния из начальной вершины s во все вершины графа. Требуется, чтобы в графе не было ребер с отрицательным весом.

? На каждой итерации основного цикла алгоритм выбирает из необработанных вершин ту, до которой расстояние минимально. Затем перебираются все ребра, начинающиеся в этой вершине, и с их помощью уиеньшаются расстояния. Каждая вершина обрабатывается только один раз. После обработки вершины расстояние до нее больше не изменяется.

? Граф представлен в виде списков смежности, так что g[a] содержит пары (b, w), если существует ребро веса w, соединяющее вершины a и b. Очередь с приоритетом q содержит пары вида (-w, b), означающие, что текущее расстояние до вершины b равно w и используется для быстрого поиска вершины с наименьшим значением расстояния. Массив dist содержит расстояния до всех вершин, массив used позволяет узнать, была ли вершина обработана.
*/

line parent(n) // code: нужно для восстановления пути
line dist(n, INF);
line used(n, 0);

priority_queue <pair <int, int>> q;

q.push({ 0, s });
dist[s] = 0;

while (!q.empty()) {
    int a = q.top().second; q.pop();

    if (used[a]) //  если вершина уже была посещена
        continue;

    used[a] = true;

    for (auto i : d[a]) {
        auto [b, w] = i;

        if (dist[a] + w < dist[b]) {
            dist[b] = dist[a] + w;
            q.push({ -dist[b], b });

            parent[b] = a; // code: нужно для восстановления пути
        }
    }
}

/*
& Дейкстра с выводом кратчайшего пути
? Требуется восстановить кратчайший путь из вершины s в вершину f. Чтобы это сделать, достаточно поддерживать массив предков parents и изменять предка каждой вершины во время ее релаксации. 

? Путь восстанавливается одним проходом по массиву предков от f до s.
*/

line path;

int i = f;
    
while (i != s) {
    path.push_back(i);
    i = parent[i];
}

path.push_back(s);               // путь начинается с вершины s
reverse(begin(path), end(path)); // путь в порядке обхода верщин