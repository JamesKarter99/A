/*
* ------------ АЛГОРИТМ ФЛОЙДА ------------
^ O(n^3)
$ флойд $ флойд_проверка_на_наличие_отрицательного_цикла $ флойд_проверка_на_наличие_цикла $ флойд_поиск_вершин_на_отрицательных_циклах $ флойд_транзитивное_замыкание
# матрица_смежности
? Алгоритм нахождения кратчайших путей между всеми парами вершин. Предполагается, что граф не содержит отрицательных циклов.  В противном случае, для некотрых пар ответ будет бесконечно малым.

? Граф представлен матрицей смежности размером n×n, в которой каждый элемент задает длину ребра между соответствующими вершинами. Кроме того, требуется, чтобы выполнялось равенство d[i][i] = 0 для всех значений i. Предполагается, что если между двумя вершинами нет ребра, то в матрице смежности записано достаточно большое число INF, которое больше любого пути в графе.	
*/

for (int k(0); k < n; k++) {
	for (int i(0); i < n; i++) {
		for (int j(0); j < n; j++) {
			d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
		}
	}
}

/* 
& проверка на наличие отрицательного цикла
? Алгоритм Флойда последовательно релаксирует растояния между всеми парам вершин (i, j), в том числе и теми, у которых i = j. Поскольку начальное расстояние между парой вершин (i, i) равно нулю, то релаксация может произойти только при наличии такой вершины k, что d[i][k] + d[k][i] < 0, что означает наличие отрицательного цикла, проходящего через вершину i. Из этого следует, что при наличии отрицательного цикла после завершения алгоритма в матрице смежности на главной диагонали появляются отрицательные числа. 

? При этом стоит учитывать, что при наличии отрицательного цикла расстояния могут уменьшаться экспоненциально, поэтому для предотвращения переполнения все вычисления стоит ограничивать снизу величиной –INF, либо проверять наличие отрицательных чисел на главной диагонали во время подсчета.
*/

for (int k(0); k < n; k++) {
        for (int i(0); i < n; i++) {
            for (int j(0); j < n; j++) {
                if (d[i][k] < INF && d[k][j] < INF) { // эти условия нужны для того, чтобы алгоритм не совершал переходов из тех состояний, где уже стоит INF, т.е. "нет пути"
                    d[i][j] = min(d[i][j], max(-INF, d[i][k] + d[k][j])); // ограничение снизу
                }
            }
        }
    }

for (int i(0); i < n; i++) {
	if (d[i][i] < 0) {
		// отрицательный цикл найден
	}
}


/*
& проверка на наличие цикла
? Дан граф с неотрицательными весами ребер. Требуется проверить, есть ли в нем цикл. Для этого достаточно инвертировать значения всех весов ребер (умножить на -1) и сделать проверку на наличие отрицательного цикла. Кроме того, если вершины i и j не соединены ребром, то значение d[i][j] следует задать как INF. 
*/

/*
& флойд_поиск_вершин_на_отрицательных_циклах
? Пусть для матрицы смежности уже выполнен алгоритм Флойда и в графе обнаружен цикл отрицательного веса. Напомним, что признаком наличия цикла отрицательного веса для данного алгоритма является наличие отрицательныз чисел на главной диагонали матрицы смежности. Но как понять, какие вершины входят в этот цикл? Рассмотрим произвольное ребро d[i][j]. Если оно равно INF - то между вершинами i и j нет ребра. Если d[i][j] равнокакому-либо другому значению, то может быть только два варианта: 
> либо ребро между вершинами i и j имеет вес d[i][j]
> либо ребро d[i][j] имеет сколь угодно маленький вес, т.е. i и j лежат на отрицательном цикле. Как это понять? Если от i и j есть путь к вершине k такой, что d[k][k] < 0 (т.е. к вершине, которая принадлежит отрицательному циклу - а такие вершины и определяет алгоритм Флойда), то i и j тоже принадлежат отрицательному циклу.

? d[i][j] будет равно -INF, если ребро d[i][j] будет принадлежать отрицательному циклу
*/

for (int k(0); k < n; k++) {
        for (int i(0); i < n; i++) {
            for (int j(0); j < n; j++) {
                if (d[i][k] < INF && d[k][j] < INF && d[k][k] < 0)
                    d[i][j] = -INF;
            }
        }
    }

/*
& построение транзитивного замыкания
? Требуется построить транзитивное замыкание графа d, т.е. такую матрицу w, что w[i][j] = 1, если от вершины i можно добраться до вершины j, и w[i][j] = 0, если нельзя.

? Изначально матрица w заполняется в соответствии графу d: если существует ребро (i, j), то w[i][j] = 1, в противном случае w[i][j] = 0. Затем внешним циклом перебираются все элементы k и для каждого из них, если он может использоваться, как промежуточный для соединения i и j, изменяется значение w[i][j].
*/

for (int k(0); k < n; k++) {
	for (int i(0); i < n; i++) {
		for (int j(0); j < n; j++) {
			w[i][j] = w[i][j] || (w[i][k] && w[k][j]);
		}
	}
} 
