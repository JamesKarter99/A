/*
* ------------ ПОИСК В ГЛУБИНУ ------------
^ O(n + m)
$ dfs $ dfs_с_цветами $ dfs_с_расстояниями_от_начальной_вершины $ dfs_планарный_граф
# список_смежности # планарный_граф
? Прямолинейный способ обхода графа. Граф представлен списками смежности d. Кроме того, используется массив used, в котором запоминаются посещенные вершины. Временная сложность, O(n+m), где n – кол-во вершин, а m – кол-во ребер.

? В некоторых приложениях алгоритма недостаточно информации о том, была посещена вершина или нет. Реализация с использованием массива color предполагает три состояния вершин: не обработана, обрабатывается и обработана – которым соответствуют три цвета: белый, серый и черный. 

? Сразу после того, как обход запускается с данной вершины, она красится в серый цвет, т.е. приобретает статус обрабатывемой вершины. При раскрутке стека вершины красятся в черный цвет и далее в обходе не используются.

*/

void dfs(int curr) {
	used[curr] = true;

	// обработать следующую вершину
	for (auto next : d[curr])
		if (!used[next])
			dfs(next);
}

//& реализация с цветами вершин
const int WHITE = 0;
const int GRAY  = 1;
const int BLACK = 2;

void dfs(int curr) {
	color[curr] = GRAY; // вершина обрабатывается...

	/// обработать следующую вершину
	for (auto next : d[curr]) 
		if (color[next] == WHITE)
			dfs(next);

	color[curr] = BLACK; // вершина обработана
}

//& вычисление "глубины" графа или кратчайших расстояний в невзвешенном графе
// ? здесь в массиве used запоминается расстояние от начальной вершины до каждой вершины, при условии, что граф не взвешенный. Другим приложением этого dfs может быть нахлждение "глубины" графа, т.е. кол-ва вершин между текущей и стартовой, считая текущую вершину.
void dfs(int curr, int deep) {
    used[curr] = deep;

    for (auto next : d[curr]) {
        if (!used[next]) {
            dfs(next, deep + 1);
        }
    }
}

//& dfs на планарном графе, в котором свободные клетки отмечены как FREE, а недоступные (зянятые) как USED
const int FREE = 0;
const int USED = 1;

void dfs(int i, int j) {
    if (d[i][j] != FREE)
        return;
    
    d[i][j] = USED;

    dfs(i + 1, j);
    dfs(i, j + 1);
    dfs(i - 1, j);
    dfs(i, j - 1);
}