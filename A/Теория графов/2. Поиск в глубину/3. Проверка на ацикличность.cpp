/*
* ------------ ПРОВЕРКА НА АЦИКЛИЧНОСТЬ ------------
^ O(n + m)
$ dfs_проверка_на_ацикличность
# dfs_с_цветами # список_смежности
? Граф представлен списками смежности d. Используется массив color, хранящий цвета всех вершин.

? Реализация для ориентированного и неориентированного графов несколько отличается. В первом случае производится серия обходов, то есть из каждой вершины, в которую еще «не заходили», запускается поиск в глубину, который при входе в вершину будет красить ее в серый цвет, а при выходе из нее – в черный. И если алгоритм попытается пойти в серую вершину, то это означает, что цикл найден.

? В случае неориентированного графа необходимо дополнительно проверять, чтобы текущее рассматриваемое из вершины ребро не является тем ребром, по которому обход попал в эту вершину.

? Если в графе есть петли, то алгоритм будет работать корректно, определяю петлю как цикл.

? Чтобы решить задачу на нахождение самого цикла, необходимо вести массив предков parent, а в момент нахождения цикла запомнить его начало и конец. Цикл восстанавливается проходом по массиву предков.

*/

const int WHITE = 0;
const int GRAY  = 1;
const int BLACK = 2;

//& ориентированный граф
bool dfs(int curr) {
	color[curr] = GRAY;

	for (auto next : d[curr]) {
		if (color[next] == WHITE)
			dfs(next);
		if (color[next] == GRAY) // todo: почему if, а не else if
			return true; //* цикл найден
	}

	color[curr] = BLACK;
	return false;
}

//& неориентированный граф
bool dfs(int curr, int prev) { 
	color[curr] = GRAY; 

	for (auto next : d[curr]) {
		if (color[next] == WHITE)
			dfs(next, curr);
		if (color[next] == GRAY && next != prev)
			return true; //* цикл найден
	}

	color[curr] = BLACK;
	return false;
}


//& восстановление цикла
//? ... цикл из dfs
for (auto next : d[curr]) {
	if (color[next] == 0) {
		parent[next] = curr;
		dfs(next);
	}
	if (color[next] == 1) {
		cycleBegin = next;
		cycleEnd   = curr;

		return true; //* цикл найден
	}
}
//? ...