/*
* ------------ DSU ------------
^ примерно O(1)
$ dsu
? Система непересекающихся множеств (DSU - Disjoint Set Union) – структура данных, состоящая из коллекции множеств, в которой каждый элемент принадлежит только одному такому множеству. Интерфейс DSU включает три операции: добавление элемента, поиск элемента-представителя (лидера) множества, содержащего данный элемент, и объединение двух множеств.

? Множества элементов хранятся в виде деревьев: одно дерево соответствует одному множеству. Корень дерева – это представитель множества. При реализации этой структуры используется массив parent, в котором для каждого элемента хранится ссылка на его предка (для элемента-представителя – сам элемент). 

? Чтобы добавить новый элемент v, необходимо просто создать новое дерево с корнем в вершине v, отмечая, что ее предок – она сама.

? Поиск лидера реализуется подъемом от вершины v по предкам, пока не встретится корень дерева, то есть пока ссылка на предка не ведет на саму себя. Для ускорения работы операции, можно «сжимать» массив предков: т.е. хранить для каждой вершины не непосредственного предка, а предка предка, предка предка предка и т.д. Это можно реализовать, если при раскрутке стека перенаправлять parent[] каждой вершины множества на лидера этого множества. Сжатие путей НЕЛЬЗЯ использовать в некоторых приложениях системы пересекающихся множеств.

? Объединение множеств, содержащих элементы a и b, начинается с поиска лидеров множеств, содержащих эти элементы. Если лидеры совпадают, то множества уже объединены. В противном случае нужно присоеди-нить одно дерево к другому, указав одного лидера в качестве предка другого, последний перестает лидером. Чтобы ускорить эту операцию, необходимо применить ранговую эвристику, которая заключается в том, что при объединении множеств то, какое дерево будет присоединено к какому, определяется не случайно, а на основе рангов. Ранг данного множества равен количеству вершин в нем. Дерево с меньшим рангом присоединяется к дереву с большим рангом. Ранговая применяется так же НЕ ВО ВСЕХ приложениях.

*/

struct DSU {
    vector <int> parent;
 
    DSU(int n)
        : parent(n)
    {
        for (int i(0); i < n; i++)
            parent[i] = i;
    }

    // доюавление элемента 
    void make_set(int v) {
	    parent[v] = v;
	    rank[v] = 1;
    }
 
    // 
    int find_set(int p) {
        if (parent[p] == p)
            return p;
 
        return parent[p] = find_set(parent[p]);
    }
 
    void union_sets(int a, int b) {
        a = find_set(a);
        b = find_set(b);
 
        parent[b] = a;
    }
};

// todo приложения DSU