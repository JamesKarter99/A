/*
* ------------ SQRT-декомпозиция ------------
^ O(sqrt(n))
$ sqrt_декомпозиция
? SQRT-декомпозиция – это струткура данных, позволяющая выполнять некоторые типичные операции (суммирование на отрезках, нахождение минимума/максимума и т.д.) за O(sqrt(n)), что значительно быстрее, чем O(n) для тривиального алгоритма.

? Основная идея заключается в том, что необходимо сделать предподсчет: разбить исходный массив [n] на блоки длинной sqrt(n), и в каждом блоке заранее определить искомое значение (сумму элементов, минимум/максимум и т.д.). Количество блоков и их длинна таким образом будут равны. Последний блок может содержать меньше элементов – это не критично. При вычислении ответа на запрос [l, r] используются уже найденные значения для тех блоков, которые полностью лежат на этом отрезке. Остается только посчитать тривиальным алгоритмом значения для крайних блоков, которые лежат на отрезке частично.

! интерфейс sqrt-декомпозиции
& В декомпозицию нельзя сразу передать весь массив данных. Нужно проинициализировать ее, передав размер данных, и потом передать каждый элемент e через соответствующую функцию.

& n                - кол-во элементов во входных данных, т.е. массива
& m                - кол-во sqrt-блоков и их длинна
& d                - входные данные
& b                - sqrt-массив

& SQRT(size)       - конструктор, инициализирует SQRT-декомпозицию для входных данных длинной size
& addElement(i, e) - добавляет элемент e во входные данные d[i] и в sqrt-массив b

& rmq(l r)         - поиск МАКСИМАЛЬНОГО элемента в на отрезке [l, r] в d:
? ПЕРВЫЙ ШАГ: определение номеров sqrt-блоков, которые полностью входят в диапазон [l, r] (__1__)
? ВТОРОЙ ШАГ: поиск ответа. Есть два случая:
        > 1. Диапазон [l, r] входит в один sqrt-блок, такой случай можно решить наивным алгоритмом (__2__)
        > 2. В диапазон входин некоторое количество (возможно нулевое) полных sqrt-блоков и один или два чачстичных (левый и правый). Это случай нужно рассмотреть более детально. Для начала найдем нужное значение в тех sqrt-блоках, которые ГАРАНТИРОВАННО ПОЛНОСТЬЮ входят в [l, r] (__3__). Затем попробуем найти наивным поиском в массиве входных данных d нужное значение в левом (возможно частичном) блоке [l, (cl+1)*m] (__4__) и в правом (тоже возможно частином) блоке [cr*m; r] (__5__). 
		
		warning: Поиск значений в частичных блоках будет выполняться даже в том случае, если все блоки будут полностью лежат в указанном диапазоне [l, r]. В таком случае фактически блоки будут полными, но для данного алгоритмы они все-равно будут частичными, так как в цикле поиска значения в полных блоках (__3__) эти блоки не рассматриваются (из-за того, что i = cl + 1 и i < r  в цикле).

		? Итак, пусть дана последовательность {1, 2, 3, 1, 4, 4, 6, 2, 0} из 9 элементов: n = 9, m = 3. Пусть мы ищем значение операции rmq(2, 8). Номера крайних блоков равны cl = 0 и cr = 2 (всего блоков 3, но они нумеруются с нуля). Поиск в полных блоказ затронет только блок с номером 1. Наивный поиск в левом начинается с l, потому что это крайняя точка указанного диапазона, и заканчивается в ячейке до (cl + 1)*m, потому что это номер первой ячейки следующего за крайним левым блоком блока. Аналогично и с правым sqrt-блоком.

? чтобы реализовать нахождение значени сумма на отрезках, количества, минимума нужно изменить операции в функии addElement и в функции rmq (__6__).
*/

struct SQRT {
	int n, m; 
	line d;
	line b;

	SQRT(int size) {
		n = size;
		m = ceil(sqrt(n + .0));

		d.resize(n);
		b.resize(m);
	}

	void addElement(int i, int e) {
		d[i] = e;

		int j = i / m;
		b[j] = max(b[j], e); // % 6
	}

	int rmq(int l, int r) {
		// номера "крайних" sqrt-блоков
		int cl = l / m; // % 1
		int cr = r / m;

		// этот случай надо обработать отдельно
		if (cl == cr) { // % 2
			for (int i(l); i <= r; i++)
				mx = max(mx, d[i]);

			return mx;
		}

		// полные sqrt-блоки
		for (int i(cl + 1); i < cr; i++)      // % 3
			mx = max(mx, b[i]); // % 6

		// частичный левый блок
		for (int i(l); i < (cl + 1) * m; i++) // % 4
			mx = max(mx, d[i]); // % 6

		// частичный правый блок
		for (int i(cr* m); i <= r; i++)       // % 5
			mx = max(mx, d[i]); // % 6

		return mx;
	}
};