/*
* ------------ ГАНГСТЕРЫ ------------
& меньшиков
~ одномерная_динамика
? всю информацию о гангстерах юудем хранить в списке d объектов gang. Помимо характеристик гангстеров хранится еще число v - подответ на подзадача. Что это значит? Для начала опишу, как будем решать. Сначала удалил из рассмотрения всех гангстеров (__1__), которые гарантированно не смогут прийти на тусовку в ресторан, т.е. тех, чья полнота больше времени прибытия: двери не успеют открыться настолько широко к этому времени. Далее всех оставшихся отсортируем по времени прибытия по возщрастанию. Так вот, значение v для i-го гангстера будет означать, что d[i].v является ответом на подзадачу для первых i гангстеров (уже отсортированных). Изначально на этапе чтения входных данных ответ для каждой подзадачи равен богатству гангстера (__2__). Это первоначальные ответы, далее мы будем их улучшать.

? Как улучшать? Переберем все пары гангстеров i и j такие, что за i-ым гангстером придет i-й, т.е. j < i. Проверим, возможно ли такое, что приняв j-го гангстера, двери успеют раскрыться(закрыться) так, чтобы принять еще и i-го (__3__). Если могут, то выберем наибольший ответ из, того, что получили для этого гангстера ранее (мы перебирали куча пар i/j, такое вполне могло произойти) и из того, что можем получить, если "придем" из j-го гангстера в i-ый.

? в ответ выводим максимальный v всех гангстеров из d.
*/

#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

struct gang {
    // время прихода, богатство и полнота + ответ на подзадачи
    int t, p, s, v;
};

int main() {
    // ...
    ios::sync_with_stdio(false);
    int n, k, t;
    cin >> n >> k >> t;

    vector <gang> temp(n), d;

    for (auto& i : temp) cin >> i.t;
    for (auto& i : temp) cin >> i.p;
    for (auto& i : temp) cin >> i.s;

    for (auto i : temp) {
        if (i.s <= i.t) { // % 1
            i.v = i.p;    // % 2
            d.push_back(i);
        }
    }

    sort(d.begin(), d.end(), [](gang a, gang b) {
        return a.t < b.t;
    });

    // DP
    for (int i(1); i < d.size(); i++) {
        for (int j(0); j < i; j++) {
            if (d[i].t - d[j].t >= abs(d[i].s - d[j].s)) { // % 3
                d[i].v = max(d[i].v, d[j].v + d[i].p);
            }
        }
    }

    int mx(0);
    for (auto i : d) {
        mx = max(mx, i.v);
    }
    cout << mx;

    return 0;
}