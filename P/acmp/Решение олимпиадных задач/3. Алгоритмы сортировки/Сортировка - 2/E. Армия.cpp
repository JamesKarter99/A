/*
* ------------ АРМИЯ ------------
& сортировка - 2
~ sqrt_декомпозиция
todo: дерево Фенвика
? Рассматриваем произвольный ряд на позиции i (__1__). Пусть e - это высота i-го солдата. Как узнать, сколько солдат выше него, которые находятся левее в этом ряду? Наивное решение просто перебирает весь ряд от 0-го до солдата с номером i-1 и смотрит, сколько из них выше текущего i-го. Такое решение слишком долгое. Поэтому предлагается использовать структуру данных, выполняющую вычесления на диапазонах быстрее, чем за O(n). Можно использовать SQRT-декомпозицию или дерево Фенвика.

? Итак, пусть мы прочитали из входных данных для какого-то произвольного ряда числе e на i-ой позиции. Запишем в массив d (__2__) d[e] = 1. Это значит, что теперь рост этого солдата мы возможно (если он окажется выше рассматриваемого) будем учитывать при вычислении кол-ва солдат, стоящих левее от какого-то другого рассматриваемого солдата и выше него. 

? А как будем вычислять это кол-во? Рост некоторого солдата равен e. Тогда в массиве d надо подсчитать кол-во единичек (или, иначе говоря, их сумму) на диапазоне [e + 1, n - 1] (e + 1, потому что мы не рассматриваем текущего, т.к. сравниваем с ним, а n - 1, потому что нумерация в массиве начинается с нуля и для удобства от роста каждого солдата отняли единицу (__3__)).
*/

#include <iostream>
#include <vector>
#include <algorithm>
#include <math.h>

using namespace std;

using line = vector <int>;
using matrix = vector <line>;

struct SQRT {
    int n, m;
    line d, b;

    SQRT(int size) {
        n = size;
        m = ceil(sqrt(size + .0));

        d.resize(n);
        b.resize(m);
    }

    // немного другая логика функции: передаем в функцию само число e и записывам в d[e] = 1, т.к. d[i] означает, что солдат с ростом i уже встречался в текущем ряду.
    void addElement(int e) {
        d[e] = 1; // % 2
        b[e/m]++;
    }

    int getSum(int l, int r) {
        int cl = l / m;
        int cr = r / m;

        int sum(0);

        if (cl == cr) {
            for (int i(l); i <= r; i++)
                sum += d[i];

            return sum;
        }

        for (int i(cl + 1); i < cr; i++)
            sum += b[i];

        for (int i(l); i < (cl + 1) * m; i++)
            sum += d[i];

        for (int i(cr * m); i <= r; i++)
            sum += d[i];

        return sum;
    }
};

int main() {
    // ...
    ios::sync_with_stdio(false);
    int n, k, amount(0);
    cin >> n >> k;

    while (k--) {
        SQRT d(n);

        for (int i(0); i < n; i++) { // % 1
            int e;
            cin >> e; // рост текущего солдата

            e--;
            d.addElement(e);

            //! наивный поиск: TLE 10 тест
            //! for (int t(0); t < j; t++) {
            //!     amount += d[t] > d[j];
            //! }

            // SQRT
            if (e + 1 <= n - 1) // % 3
                amount += d.getSum(e + 1, n - 1);
        }
    }

    cout << amount;

    return 0;
}
