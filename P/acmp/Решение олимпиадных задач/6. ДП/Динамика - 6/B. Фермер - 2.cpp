/*
* ------------ ШАБЛОН ------------
~ одномерная_динамика
? итак, суть в чем: дана прямоугольная матрица d[n][m], ссостоящая из нулей и единиц. Требуется найти наибольший блок прямоугольной формы, состоящий из единиц.

? Введем понятие ПОЛОСКА и ДЛИННА ПОЛОСКИ для I-Й СТРОКИ. Возьмем произвольные i и j. Если d[i][j] = 0, то не существует такой полоски, состоящей из единиц, которая начинается в i-й строке в столбце k <= j. Если же d[i][j] = 1, то длинна полоски равна кол-ву непрерывных единиц в i-й строке с k <= j до j-го столбца. 

? Будем перебирать столбцы (__1__). Для сразу же обновим длины полосок, заканчивающихся в текущем столбце (__2__). Затем, перебирая строки (__3__), будем находить площадь наибольшего прямоугольника, состоящего только из единиц, правый нижний угол которого оканчивается в d[i][j]. Итак, первое замечание, если d[i][j] = 0, то можно пропускать эту клетку - в ней ни один прямоугольниr не оканчивается. Далее, введем переменныe t и k. k нужня для перенбора строк меньших i, а t - для хранения наименьшей полоски из     c[k...i]. Ну и перебирая все k <= i, одновременно поддерживая наименьшее t из имеющихся c[k...i], будем обновлять r, т.е. ответ. Важно отметить, что если (i + 1)*t меньше чем уже найденный ответ, то цикл while нет смысла запускать дальше. (i + 1)*t - это наибольшая площадь прямоугольника, которую можно получить в d[i][j], в лучшем случае, т.е. когда d будет заполнен единицами под текущей полоской длинной t на i-й строке (__4__).
*/

#include <iostream>
#include <algorithm>
#include <vector>

#define all(s) s.begin(), s.end()

using namespace std;

using T = long double;
using line = vector <int>;
using matrix = vector <line>;

int main() {
    // ...
    ios::sync_with_stdio(false);
    int n, m;
    cin >> n >> m;

    matrix d(n, line(m));
    for (int i(0); i < n; i++) {
        for (int j(0); j < m; j++) {
            char c;
            cin >> c;

            d[i][j] = (c == '1');
        }
    }

    // решение
    int r(0);
    line c(n + 1); // длинна полосок, состоящих из непрерывных единиц, в строках d

    // % 1. перебор номеров столбцов
    for (int j(0); j < m; j++) {
        
        // % 2. подсчет длинны полоски в i-й строке, заканчивающейся в j-м столбце
        for (int i(0); i < n; i++)
            c[i] = (d[i][j] ? c[i] + 1 : 0);

        // % 3. перебор строк
        for (int i(0); i < n; i++) {
            /// в клетке d[i][j] не модет оканчиваться прямоугольник, если в ней лежит 0
            if (d[i][j] == 0) continue;

            int t = c[i];
            int k = i;

            while (k >= 0 && t*(i + 1) > r) { // % 4. оптимизация
                /// увеличивая высоту прямоугольника (это разность между i и k) мы должны выбрать наименьшую длинну полосок из c[k ... i]
                t = min(t, c[k]); 
                r = max(r, t * (i - k + 1));

                k--;
            }

        }
    }

    cout << r;

    return 0;
}