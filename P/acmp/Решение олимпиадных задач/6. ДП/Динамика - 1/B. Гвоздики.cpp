/*
* ------------ ГВОЗДИКИ ------------
& Дианмика - 1
~ одномерная_динамика
? В комментариях все расписал, не так сложно, как можнт показаться
*/

#include <iostream>
#include <vector>
#include <algorithm>
#include <set>
#include <tuple>

using namespace std;

using line = vector <int>;

int main() {
	// ...
	ios::sync_with_stdio(false);
	int n;
	cin >> n;

	line d(n);
	for (auto& i : d)
		cin >> i;

	sort(d.begin(), d.end());

	// code: вычисление расстояний между парами гвоздиков
	line p(n);
	for (int i(1); i < n; i++) {
		p[i] = d[i] - d[i - 1];
	}

	// code: вычисление ответов на подзадачу
	line r(n);
	
	r[0] = 0;			// code: гвоздик один, пары нет, поэтому длинна нулевая
	r[1] = p[1];		// code: для одной пары динна равна расстояние между гвоздиками этой пары
	
	if (n > 2) {
		r[2] = r[1] + p[2]; // code: для двух пар, т.е. трех гвоздиков, длинна равно суммарному расстоянию между ними (потому что любой гвоздик должен быть связан хотя бы с одним другим)

		for (int i(3); i < n; i++) {
			// code: уже есть некоторая последовательность связанных гвоздей до i-1 с минимальной длинной связей - это ответ для n = i-1. Так-же есть ответы для меньших значений n > 0. Суть в том, что мы обязаны поддерживать одно свойство такой последовательности: крайние гвоздики обязательно долдны быть включены в связи. Поэтому обязательно в ответ войдет связь между i и i-1 гвоздиком (p[i]). code: Так же мы должны добавить к текущей последовательности либо связь между i-1 и i-2 гвоздиком, либо между i-2 и i-3. Соответственно, это два разных подответа - r[i-1] и r[i-2]
			r[i] = p[i] + min(r[i - 1], r[i - 2]);
		}
	}

	cout << r[n - 1];
	
	return 0;
}