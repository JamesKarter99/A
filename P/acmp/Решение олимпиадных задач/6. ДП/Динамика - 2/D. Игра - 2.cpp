/*
* ------------ ИГРА - 2 ------------
& Дианмика - 2
~ двумерная_динамика ~ рекурсия
? Решение этой задачи основывается на построении дерева из верщин-пар {l, r} таких, что каждая вершина означает, что один из игроков может выбрать число с номером l, или число с номером r, и что числа в диапазоне [l, r] еще не были выбраны. Листьями дерева будут вершины, где l = r, а случая, когда l > r, нет в дереве (__1__), но об этом позже.

? Переберем рекурсивно все пары {l, r}, которые можно получить в ходе данной игры, т.е. зачеркивая только крайние числа. А при раскрутке стека будем определять сумму очков, которую может набрать ПЕРВЫЙ игрок при оптимальной игре обоих игроков. У каждой вершины (не листа) есть два потомка - это два варианта, когда текущий игрок выбирает либо левое число, либо правое. Допустим из некоторой вершины делает ход первый игрок: тогда запомним кол-во очков для той вершины, где оно наибольшее (__2__). Для второго игрока все наоборот (__3__). 

? Функция get(i, who) принимает номер числа и номер игрока, и возвращает само число, если ход делает первый игрок, или это число, умноженное на -1.
? Функция rec(l, r, who) принимает пару {l, r} и номер игрока. Возвразает овтет для этой пары.

? ДИНАМИКА здесь заключается в том, что в двумерном массиву p[l][r] равно кол-ву очков, которое может набрать первый игрок. Соответсвтенно, если в рекурсии можно использовать уже ранее найденное значение (оно не равно -INF) (__4__), то мы это делаем.
*/

#include <iostream>
#include <vector>
#include <algorithm>
#include <set>
#include <tuple>

using namespace std;

using line = vector <int>;
using matrix = vector <line>;

const int INF = 0x3f3f3f3f;
const int FIRST  = 1;
const int SECOND = 2;

int n;

line d;
matrix p;

int get(int i, int who) {
	return d[i] * (who == FIRST ? 1 : -1);
}

int rec(int l, int r, int who) {
	if (p[l][r] != -INF)
		return p[l][r]; // % 4
	
	if (l > r)  // % 1
		return 0;

	if (l == r) {
		return get(l, who);
	}

	int leftResult  = rec(l + 1, r, 3 - who) + get(l, who); // % 2
	int rightResult = rec(l, r - 1, 3 - who) + get(r, who); // % 3

	if (who == FIRST) {
		p[l][r] = max(leftResult, rightResult);
	}
	else {
		p[l][r] = min(leftResult, rightResult);
	}

	return p[l][r];
}

int main() {
	// ...
	ios::sync_with_stdio(false);
	cin >> n;

	d.resize(n);
	p.resize(n, line(n, -INF));
	for (auto& i : d)
		cin >> i;

	// решение
	int ans = rec(0, n - 1, FIRST);

	if (ans == 0) {
		cout << 0;
	}
	else {
		cout << (ans > 0 ? 1 : 2);
	}

	return 0;
}