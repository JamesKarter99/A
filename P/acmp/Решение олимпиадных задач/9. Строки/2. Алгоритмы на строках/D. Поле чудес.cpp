/*
* ------------ Поле чудес ------------
~ преффикс_функция
? Да, решение основано на использовании преффикс-функции. Суть в том, что нужно найти минимальный период заданной последовательности. Можно бы было вывести в ответ период, равный разности длинны последовательности и длинны наибольшего бордера, но не всегда искомый минимальный период равен длинне наибольшего бордера. Например, в случае:
/ d = 1 2 1 3 1 2 1 - последовательность
/ p = 0 0 1 0 1 2 3 - преффикс-функция
      ^^^^^   ^^^^^ - этот бордер найдет алгоритм преффикс-функции
      ^^^^^^^^^^^   - а этот период будет ответом
? если бы не такие случаи, то в ответ мы вывели бы 4 (7 - 3). Но у нас есть условие: "барабан сделал целое число оборотов, то есть последний сектор совпал с первым". А значит, период тут равен 6, несмотря на то, что у строки максимальный бордер - это {1, 2, 3}. Как с этим бороться? Длинна периода равна: n - (длинна бордера), но нужно дополнительно проверить, что n-1 делится на длинну периода. Если не делится, то нужно найти боьшее значение периода. 
? Почему n-1 и почему нужно проверить, делится ли это число на период?
todo: А почему n - 1?
? Я думаю, потому что последняя цифра - это повторение начала сектора. А делимость нужно проверить, потому что барабан прокрутили целое количество раз.

*/

#include <iostream>
#include <algorithm>
#include <vector>
#include <map>
#include <vector>

using namespace std;

using line = vector <int>;

line preffix(const vector <int>& s) {
    int n = s.size();
    line d(n);

    int i(1), j(0);
    while (i < n) {
        if (s[i] == s[j]) { // обычное сравнение
            d[i] = j + 1;
            i++;
            j++;
        }
        else if (j == 0) {
            d[i] = 0;
            i++;
        }
        else {
            j = d[j - 1];
        }
    }

    return d;
}

int main() {
    // ...
    ios::sync_with_stdio(false);
    int n;
    cin >> n;

    line d(n);
    for (auto& i : d)
        cin >> i;

    line p = preffix(d);

    int len = p.back();
    while (true) {
        int period = n - len; 
        if ((n - 1) % period == 0) {
            cout << period;
            return 0;
        }

        // todo: это не понятно
        len = p[len - 1]; // переход к меньшей длинне бордера
    }

    return 0;
}